<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name="generator" content="Jekyll">

  <title>Hack The Box - Forensics - TrueSecrets</title>

  <link rel="stylesheet" href="/css/main.css">
  <link rel="shortcut icon" type="image/png" href="/assets/favicon.png">
  <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" /> <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Hack The Box - Forensics - TrueSecrets | OFenomeno</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Hack The Box - Forensics - TrueSecrets" />
<meta name="author" content="OFenomeno" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction TrueSecrets is an “Easy” forensics challenge on HackTheBox. I thought that it will be a bit tougher to resolve it, nevertheless it was very important to read completely the description to identify this challenge’s context. Challenge Description Our cybercrime unit has been investigating a well-known APT group for several months. The group has been responsible for several high-profile attacks on corporate organizations. However, what is interesting about that case, is that they have developed a custom command &amp; control server of their own. Fortunately, our unit was able to raid the home of the leader of the APT group and take a memory capture of his computer while it was still powered on. Analyze the capture to try to find the source code of the server. So the main point was to find the source code of the custom C2 server located on the cybercriminal’s computer. My work environment for resolving this challenge: Windows 11 WSL2 with Ubuntu 20.04 LTS An Exegol instance installed on WSL2 Memory analysis For the memory analysis (TrueSecrets.raw, the only file provided for this challenge), I used Volatility2 installed on Exegol (Volatility3 is also available). Firstly I identified the OS profile with imageinfo command. Little tip: always redirect the output into a text file in order to avoid time loss. volatility2 -f TrueSecrets.raw imageinfo &gt; imageinfo.txt The profile was Win7SP1x86_23418. After that, I decided to analyze processes with pstree, network connexions with netscan, try to find minjected code with malfind but I remembered that the aim of this challenge was to find the source code of the custom C2 server located on the cybercriminal’s computer..yes life is easier when you start thinking… So… to find the source code file, Volatility’s filescan command is your friend. volatility2 -f TrueSecrets.raw --profile=Win7SP1x86_23418 filescan &gt; filescan.txt After a simple analysis of the filescan output, I found interesting things related to the IEUser under usual directories: Desktop, Downloads and Documents. cat filescan.txt | grep &#39;Users\\IEUser\\D.*&#39; Despite the presence of the DumpIt.exe file, the context of the challenge directed me to development.tc and backup_development.zip. Due to file permissions, I wasn’t able to dump developement.tc, however I was able to dump backup_development.zip. volatility2 -f TrueSecrets.raw --profile=Win7SP1x86_23418 dumpfiles -Q 0x000000000bbf6158 --name backup_developement -D /workspace/htb/chall/forensics/truesecrets/filedump After dumping the zip file, I extracted its content… and… The TrueCrypt volume was retrieved, but what about the related passphrase? If you check the Volatility cheatsheet, you can see that it’s possible to extract the passphrase with truecryptpassphrase command. Truecrypt… So we have the truecrypt volume and its passphrase, but how to mount that? Thanks to this link, I successfully mounted the Truecrypt volume with cryptsetup. sudo cryptsetup --type tcrypt open /path/to/truecrypt-volume mapping-name sudo mount -o uid=1001 /dev/mapper/mapping-name /media/tcv After mouting the trucrypt volume under /media/tsecrets I started to analyze its content. AgentServer.cs I was nearly sure that it was the source code of the custom C2 server…and I was right. using System; using System.IO; using System.Net; using System.Net.Sockets; using System.Text; using System.Security.Cryptography; class AgentServer { static void Main(String[] args) { var localPort = 40001; IPAddress localAddress = IPAddress.Any; TcpListener listener = new TcpListener(localAddress, localPort); listener.Start(); Console.WriteLine(&quot;Waiting for remote connection from remote agents (infected machines)...&quot;); TcpClient client = listener.AcceptTcpClient(); Console.WriteLine(&quot;Received remote connection&quot;); NetworkStream cStream = client.GetStream(); string sessionID = Guid.NewGuid().ToString(); while (true) { string cmd = Console.ReadLine(); byte[] cmdBytes = Encoding.UTF8.GetBytes(cmd); cStream.Write(cmdBytes, 0, cmdBytes.Length); byte[] buffer = new byte[client.ReceiveBufferSize]; int bytesRead = cStream.Read(buffer, 0, client.ReceiveBufferSize); string cmdOut = Encoding.ASCII.GetString(buffer, 0, bytesRead); string sessionFile = sessionID + &quot;.log.enc&quot;; File.AppendAllText(@&quot;sessions\&quot; + sessionFile, Encrypt( &quot;Cmd: &quot; + cmd + Environment.NewLine + cmdOut ) + Environment.NewLine ); } } private static string Encrypt(string pt) { string key = &quot;AKaPdSgV&quot;; string iv = &quot;QeThWmYq&quot;; byte[] keyBytes = Encoding.UTF8.GetBytes(key); byte[] ivBytes = Encoding.UTF8.GetBytes(iv); byte[] inputBytes = System.Text.Encoding.UTF8.GetBytes(pt); using (DESCryptoServiceProvider dsp = new DESCryptoServiceProvider()) { var mstr = new MemoryStream(); var crystr = new CryptoStream(mstr, dsp.CreateEncryptor(keyBytes, ivBytes), CryptoStreamMode.Write); crystr.Write(inputBytes, 0, inputBytes.Length); crystr.FlushFinalBlock(); return Convert.ToBase64String(mstr.ToArray()); } } } So understanding the AgentServer.cs file, it encrypts command executions on victims’ computers into session files with DES ciphering and encodes it with Base64. Under the session malware_agent/sessions/ I found 3 encrypted log files generated by the code above: 5818acbe-68f1-4176-a2f2-8c6bcb99f9fa.log.enc c65939ad-5d17-43d5-9c3a-29c6a7c31a32.log.enc de008160-66e4-4d51-8264-21cbc27661fc.log.enc I wrote the Decrypt function to decrypt log files content, but intuitively, I directly chose to decrypt the last line of the last file (i.e de008160-66e4-4d51-8264-21cbc27661fc.log.enc) because I felt that the flag was here (no joke). +iTzBxkIgVWgWm/oyP/Uf6+qW+A+kMTQkouTEammirkz2efek8yfrP5l+mtFS+bWA7TCjJDK2nLAdTKssL7CrHnVW8fMvc6mJR4Ismbs/d/fMDXQeiGXCA== private static string Decrypt(string ct) { string key = &quot;AKaPdSgV&quot;; string iv = &quot;QeThWmYq&quot;; byte[] keyBytes = Encoding.UTF8.GetBytes(key); byte[] ivBytes = Encoding.UTF8.GetBytes(iv); byte[] inputBytes = Convert.FromBase64String(ct); using (DESCryptoServiceProvider dsp = new DESCryptoServiceProvider()) { var mstr = new MemoryStream(); var crystr = new CryptoStream(mstr, dsp.CreateDecryptor(keyBytes, ivBytes), CryptoStreamMode.Write); crystr.Write(inputBytes, 0, inputBytes.Length); crystr.FlushFinalBlock(); return Encoding.UTF8.GetString(mstr.ToArray()); } } And here is the flag… Conclusion This was an easy one. If you have any questions or feedback on this writeup, or if you simply want talk about cybersecurity you can DM me on Twitter @o_fenomen0 or on Discord @0xofenomeno." />
<meta property="og:description" content="Introduction TrueSecrets is an “Easy” forensics challenge on HackTheBox. I thought that it will be a bit tougher to resolve it, nevertheless it was very important to read completely the description to identify this challenge’s context. Challenge Description Our cybercrime unit has been investigating a well-known APT group for several months. The group has been responsible for several high-profile attacks on corporate organizations. However, what is interesting about that case, is that they have developed a custom command &amp; control server of their own. Fortunately, our unit was able to raid the home of the leader of the APT group and take a memory capture of his computer while it was still powered on. Analyze the capture to try to find the source code of the server. So the main point was to find the source code of the custom C2 server located on the cybercriminal’s computer. My work environment for resolving this challenge: Windows 11 WSL2 with Ubuntu 20.04 LTS An Exegol instance installed on WSL2 Memory analysis For the memory analysis (TrueSecrets.raw, the only file provided for this challenge), I used Volatility2 installed on Exegol (Volatility3 is also available). Firstly I identified the OS profile with imageinfo command. Little tip: always redirect the output into a text file in order to avoid time loss. volatility2 -f TrueSecrets.raw imageinfo &gt; imageinfo.txt The profile was Win7SP1x86_23418. After that, I decided to analyze processes with pstree, network connexions with netscan, try to find minjected code with malfind but I remembered that the aim of this challenge was to find the source code of the custom C2 server located on the cybercriminal’s computer..yes life is easier when you start thinking… So… to find the source code file, Volatility’s filescan command is your friend. volatility2 -f TrueSecrets.raw --profile=Win7SP1x86_23418 filescan &gt; filescan.txt After a simple analysis of the filescan output, I found interesting things related to the IEUser under usual directories: Desktop, Downloads and Documents. cat filescan.txt | grep &#39;Users\\IEUser\\D.*&#39; Despite the presence of the DumpIt.exe file, the context of the challenge directed me to development.tc and backup_development.zip. Due to file permissions, I wasn’t able to dump developement.tc, however I was able to dump backup_development.zip. volatility2 -f TrueSecrets.raw --profile=Win7SP1x86_23418 dumpfiles -Q 0x000000000bbf6158 --name backup_developement -D /workspace/htb/chall/forensics/truesecrets/filedump After dumping the zip file, I extracted its content… and… The TrueCrypt volume was retrieved, but what about the related passphrase? If you check the Volatility cheatsheet, you can see that it’s possible to extract the passphrase with truecryptpassphrase command. Truecrypt… So we have the truecrypt volume and its passphrase, but how to mount that? Thanks to this link, I successfully mounted the Truecrypt volume with cryptsetup. sudo cryptsetup --type tcrypt open /path/to/truecrypt-volume mapping-name sudo mount -o uid=1001 /dev/mapper/mapping-name /media/tcv After mouting the trucrypt volume under /media/tsecrets I started to analyze its content. AgentServer.cs I was nearly sure that it was the source code of the custom C2 server…and I was right. using System; using System.IO; using System.Net; using System.Net.Sockets; using System.Text; using System.Security.Cryptography; class AgentServer { static void Main(String[] args) { var localPort = 40001; IPAddress localAddress = IPAddress.Any; TcpListener listener = new TcpListener(localAddress, localPort); listener.Start(); Console.WriteLine(&quot;Waiting for remote connection from remote agents (infected machines)...&quot;); TcpClient client = listener.AcceptTcpClient(); Console.WriteLine(&quot;Received remote connection&quot;); NetworkStream cStream = client.GetStream(); string sessionID = Guid.NewGuid().ToString(); while (true) { string cmd = Console.ReadLine(); byte[] cmdBytes = Encoding.UTF8.GetBytes(cmd); cStream.Write(cmdBytes, 0, cmdBytes.Length); byte[] buffer = new byte[client.ReceiveBufferSize]; int bytesRead = cStream.Read(buffer, 0, client.ReceiveBufferSize); string cmdOut = Encoding.ASCII.GetString(buffer, 0, bytesRead); string sessionFile = sessionID + &quot;.log.enc&quot;; File.AppendAllText(@&quot;sessions\&quot; + sessionFile, Encrypt( &quot;Cmd: &quot; + cmd + Environment.NewLine + cmdOut ) + Environment.NewLine ); } } private static string Encrypt(string pt) { string key = &quot;AKaPdSgV&quot;; string iv = &quot;QeThWmYq&quot;; byte[] keyBytes = Encoding.UTF8.GetBytes(key); byte[] ivBytes = Encoding.UTF8.GetBytes(iv); byte[] inputBytes = System.Text.Encoding.UTF8.GetBytes(pt); using (DESCryptoServiceProvider dsp = new DESCryptoServiceProvider()) { var mstr = new MemoryStream(); var crystr = new CryptoStream(mstr, dsp.CreateEncryptor(keyBytes, ivBytes), CryptoStreamMode.Write); crystr.Write(inputBytes, 0, inputBytes.Length); crystr.FlushFinalBlock(); return Convert.ToBase64String(mstr.ToArray()); } } } So understanding the AgentServer.cs file, it encrypts command executions on victims’ computers into session files with DES ciphering and encodes it with Base64. Under the session malware_agent/sessions/ I found 3 encrypted log files generated by the code above: 5818acbe-68f1-4176-a2f2-8c6bcb99f9fa.log.enc c65939ad-5d17-43d5-9c3a-29c6a7c31a32.log.enc de008160-66e4-4d51-8264-21cbc27661fc.log.enc I wrote the Decrypt function to decrypt log files content, but intuitively, I directly chose to decrypt the last line of the last file (i.e de008160-66e4-4d51-8264-21cbc27661fc.log.enc) because I felt that the flag was here (no joke). +iTzBxkIgVWgWm/oyP/Uf6+qW+A+kMTQkouTEammirkz2efek8yfrP5l+mtFS+bWA7TCjJDK2nLAdTKssL7CrHnVW8fMvc6mJR4Ismbs/d/fMDXQeiGXCA== private static string Decrypt(string ct) { string key = &quot;AKaPdSgV&quot;; string iv = &quot;QeThWmYq&quot;; byte[] keyBytes = Encoding.UTF8.GetBytes(key); byte[] ivBytes = Encoding.UTF8.GetBytes(iv); byte[] inputBytes = Convert.FromBase64String(ct); using (DESCryptoServiceProvider dsp = new DESCryptoServiceProvider()) { var mstr = new MemoryStream(); var crystr = new CryptoStream(mstr, dsp.CreateDecryptor(keyBytes, ivBytes), CryptoStreamMode.Write); crystr.Write(inputBytes, 0, inputBytes.Length); crystr.FlushFinalBlock(); return Encoding.UTF8.GetString(mstr.ToArray()); } } And here is the flag… Conclusion This was an easy one. If you have any questions or feedback on this writeup, or if you simply want talk about cybersecurity you can DM me on Twitter @o_fenomen0 or on Discord @0xofenomeno." />
<link rel="canonical" href="http://localhost:8000/HackTheBox-Forensics-TrueSecrets" />
<meta property="og:url" content="http://localhost:8000/HackTheBox-Forensics-TrueSecrets" />
<meta property="og:site_name" content="OFenomeno" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-08-16T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Hack The Box - Forensics - TrueSecrets" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"OFenomeno","url":"ofenomeno.xyz"},"dateModified":"2023-08-16T00:00:00+02:00","datePublished":"2023-08-16T00:00:00+02:00","description":"Introduction TrueSecrets is an “Easy” forensics challenge on HackTheBox. I thought that it will be a bit tougher to resolve it, nevertheless it was very important to read completely the description to identify this challenge’s context. Challenge Description Our cybercrime unit has been investigating a well-known APT group for several months. The group has been responsible for several high-profile attacks on corporate organizations. However, what is interesting about that case, is that they have developed a custom command &amp; control server of their own. Fortunately, our unit was able to raid the home of the leader of the APT group and take a memory capture of his computer while it was still powered on. Analyze the capture to try to find the source code of the server. So the main point was to find the source code of the custom C2 server located on the cybercriminal’s computer. My work environment for resolving this challenge: Windows 11 WSL2 with Ubuntu 20.04 LTS An Exegol instance installed on WSL2 Memory analysis For the memory analysis (TrueSecrets.raw, the only file provided for this challenge), I used Volatility2 installed on Exegol (Volatility3 is also available). Firstly I identified the OS profile with imageinfo command. Little tip: always redirect the output into a text file in order to avoid time loss. volatility2 -f TrueSecrets.raw imageinfo &gt; imageinfo.txt The profile was Win7SP1x86_23418. After that, I decided to analyze processes with pstree, network connexions with netscan, try to find minjected code with malfind but I remembered that the aim of this challenge was to find the source code of the custom C2 server located on the cybercriminal’s computer..yes life is easier when you start thinking… So… to find the source code file, Volatility’s filescan command is your friend. volatility2 -f TrueSecrets.raw --profile=Win7SP1x86_23418 filescan &gt; filescan.txt After a simple analysis of the filescan output, I found interesting things related to the IEUser under usual directories: Desktop, Downloads and Documents. cat filescan.txt | grep &#39;Users\\\\IEUser\\\\D.*&#39; Despite the presence of the DumpIt.exe file, the context of the challenge directed me to development.tc and backup_development.zip. Due to file permissions, I wasn’t able to dump developement.tc, however I was able to dump backup_development.zip. volatility2 -f TrueSecrets.raw --profile=Win7SP1x86_23418 dumpfiles -Q 0x000000000bbf6158 --name backup_developement -D /workspace/htb/chall/forensics/truesecrets/filedump After dumping the zip file, I extracted its content… and… The TrueCrypt volume was retrieved, but what about the related passphrase? If you check the Volatility cheatsheet, you can see that it’s possible to extract the passphrase with truecryptpassphrase command. Truecrypt… So we have the truecrypt volume and its passphrase, but how to mount that? Thanks to this link, I successfully mounted the Truecrypt volume with cryptsetup. sudo cryptsetup --type tcrypt open /path/to/truecrypt-volume mapping-name sudo mount -o uid=1001 /dev/mapper/mapping-name /media/tcv After mouting the trucrypt volume under /media/tsecrets I started to analyze its content. AgentServer.cs I was nearly sure that it was the source code of the custom C2 server…and I was right. using System; using System.IO; using System.Net; using System.Net.Sockets; using System.Text; using System.Security.Cryptography; class AgentServer { static void Main(String[] args) { var localPort = 40001; IPAddress localAddress = IPAddress.Any; TcpListener listener = new TcpListener(localAddress, localPort); listener.Start(); Console.WriteLine(&quot;Waiting for remote connection from remote agents (infected machines)...&quot;); TcpClient client = listener.AcceptTcpClient(); Console.WriteLine(&quot;Received remote connection&quot;); NetworkStream cStream = client.GetStream(); string sessionID = Guid.NewGuid().ToString(); while (true) { string cmd = Console.ReadLine(); byte[] cmdBytes = Encoding.UTF8.GetBytes(cmd); cStream.Write(cmdBytes, 0, cmdBytes.Length); byte[] buffer = new byte[client.ReceiveBufferSize]; int bytesRead = cStream.Read(buffer, 0, client.ReceiveBufferSize); string cmdOut = Encoding.ASCII.GetString(buffer, 0, bytesRead); string sessionFile = sessionID + &quot;.log.enc&quot;; File.AppendAllText(@&quot;sessions\\&quot; + sessionFile, Encrypt( &quot;Cmd: &quot; + cmd + Environment.NewLine + cmdOut ) + Environment.NewLine ); } } private static string Encrypt(string pt) { string key = &quot;AKaPdSgV&quot;; string iv = &quot;QeThWmYq&quot;; byte[] keyBytes = Encoding.UTF8.GetBytes(key); byte[] ivBytes = Encoding.UTF8.GetBytes(iv); byte[] inputBytes = System.Text.Encoding.UTF8.GetBytes(pt); using (DESCryptoServiceProvider dsp = new DESCryptoServiceProvider()) { var mstr = new MemoryStream(); var crystr = new CryptoStream(mstr, dsp.CreateEncryptor(keyBytes, ivBytes), CryptoStreamMode.Write); crystr.Write(inputBytes, 0, inputBytes.Length); crystr.FlushFinalBlock(); return Convert.ToBase64String(mstr.ToArray()); } } } So understanding the AgentServer.cs file, it encrypts command executions on victims’ computers into session files with DES ciphering and encodes it with Base64. Under the session malware_agent/sessions/ I found 3 encrypted log files generated by the code above: 5818acbe-68f1-4176-a2f2-8c6bcb99f9fa.log.enc c65939ad-5d17-43d5-9c3a-29c6a7c31a32.log.enc de008160-66e4-4d51-8264-21cbc27661fc.log.enc I wrote the Decrypt function to decrypt log files content, but intuitively, I directly chose to decrypt the last line of the last file (i.e de008160-66e4-4d51-8264-21cbc27661fc.log.enc) because I felt that the flag was here (no joke). +iTzBxkIgVWgWm/oyP/Uf6+qW+A+kMTQkouTEammirkz2efek8yfrP5l+mtFS+bWA7TCjJDK2nLAdTKssL7CrHnVW8fMvc6mJR4Ismbs/d/fMDXQeiGXCA== private static string Decrypt(string ct) { string key = &quot;AKaPdSgV&quot;; string iv = &quot;QeThWmYq&quot;; byte[] keyBytes = Encoding.UTF8.GetBytes(key); byte[] ivBytes = Encoding.UTF8.GetBytes(iv); byte[] inputBytes = Convert.FromBase64String(ct); using (DESCryptoServiceProvider dsp = new DESCryptoServiceProvider()) { var mstr = new MemoryStream(); var crystr = new CryptoStream(mstr, dsp.CreateDecryptor(keyBytes, ivBytes), CryptoStreamMode.Write); crystr.Write(inputBytes, 0, inputBytes.Length); crystr.FlushFinalBlock(); return Encoding.UTF8.GetString(mstr.ToArray()); } } And here is the flag… Conclusion This was an easy one. If you have any questions or feedback on this writeup, or if you simply want talk about cybersecurity you can DM me on Twitter @o_fenomen0 or on Discord @0xofenomeno.","headline":"Hack The Box - Forensics - TrueSecrets","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:8000/HackTheBox-Forensics-TrueSecrets"},"url":"http://localhost:8000/HackTheBox-Forensics-TrueSecrets"}</script>
<!-- End Jekyll SEO tag -->

</head>

<body>
  <div id="wrapper">
    <header>
  <div>
    <a href="/">
    
    <h1>root@ofenomeno:~$</h1>
    </a>
    <div class="header-links">
      <a href="/about"><h2 class="header-link">About</h2></a>
<a href="/posts"><h2 class="header-link">Posts</h2></a>

    </div>
  </div>
</header>
    <div class="container">
      <section id="main_content">
        <article>
  <h2>Hack The Box - Forensics - TrueSecrets</h2>
  <time datetime="2023-08-16T00:00:00+02:00" class="by-line">16 Aug 2023</time>
  <h1 id="introduction"><a href="#Introduction"></a>Introduction</h1>
<p><strong>TrueSecrets</strong> is an “Easy” forensics challenge on HackTheBox. I thought that it will be a bit tougher to resolve it, nevertheless it was very important to read completely the description to identify this challenge’s context.</p>

<h1 id="challenge-description"><a href="#Description"></a>Challenge Description</h1>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Our cybercrime unit has been investigating a well-known APT group for several months. 
The group has been responsible for several high-profile attacks on corporate organizations.
However, what is interesting about that case, is that they have developed a custom command &amp; control server of their own. 
Fortunately, our unit was able to raid the home of the leader of the APT group and take a memory capture of his computer while it was still powered on. 
Analyze the capture to try to find the source code of the server.
</code></pre></div></div>

<p>So the main point was to find the source code of the custom C2 server located on the cybercriminal’s computer.</p>

<p>My work environment for resolving this challenge:</p>
<ul>
  <li>Windows 11</li>
  <li>WSL2 with Ubuntu 20.04 LTS</li>
  <li>An <a href="https://github.com/ThePorgs/Exegol">Exegol</a> instance installed on WSL2</li>
</ul>

<h1 id="memory-analysis"><a href="#Analysis"></a>Memory analysis</h1>

<p>For the memory analysis (TrueSecrets.raw, the only file provided for this challenge), I used Volatility2 installed on Exegol (Volatility3 is also available). Firstly I identified the OS profile with <strong>imageinfo</strong> command. Little tip: always redirect the output into a text file in order to avoid time loss.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>volatility2 -f TrueSecrets.raw imageinfo &gt; imageinfo.txt
</code></pre></div></div>

<p>The profile was <strong>Win7SP1x86_23418</strong>.</p>

<p>After that, I decided to analyze processes with <strong>pstree</strong>, network connexions with <strong>netscan</strong>, try to find minjected code with <strong>malfind</strong>  but I remembered that the aim of this challenge was to find the <strong>source code</strong> of the custom C2 server located on the cybercriminal’s computer..yes life is easier when you start thinking…</p>

<p>So… to find the source code file, Volatility’s <strong>filescan</strong> command is your friend.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>volatility2 -f TrueSecrets.raw --profile=Win7SP1x86_23418 filescan &gt; filescan.txt
</code></pre></div></div>

<p>After a simple analysis of the filescan output, I found interesting things related to the <strong>IEUser</strong> under usual directories: Desktop, Downloads and Documents.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat filescan.txt | grep 'Users\\IEUser\\D.*'
</code></pre></div></div>
<p><img src="/assets/truesecrets/grep_output.png" alt="" /></p>

<p>Despite the presence of the <strong><em>DumpIt.exe</em></strong> file, the context of the challenge directed me to <strong><em>development.tc</em></strong> and <strong><em>backup_development.zip</em></strong>.</p>

<p>Due to file permissions, I wasn’t able to dump <strong><em>developement.tc</em></strong>, however I was able to dump <strong><em>backup_development.zip</em></strong>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>volatility2 -f TrueSecrets.raw --profile=Win7SP1x86_23418 dumpfiles -Q 0x000000000bbf6158 --name backup_developement -D /workspace/htb/chall/forensics/truesecrets/filedump
</code></pre></div></div>

<p>After dumping the zip file, I extracted its content… and…
<img src="/assets/truesecrets/zip_extraction.png" alt="" /></p>

<p>The TrueCrypt volume was retrieved, but what about the related passphrase? If you check the Volatility cheatsheet, you can see that it’s possible to extract the passphrase with <strong>truecryptpassphrase</strong> command.</p>

<p><img src="/assets/truesecrets/passphrase.png" alt="" /></p>

<h1 id="truecrypt"><a href="#Truecrypt"></a>Truecrypt…</h1>

<p>So we have the truecrypt volume and its passphrase, but how to mount that?</p>

<p>Thanks to this <a href="https://www.toptip.ca/2021/01/linux-mounting-truecrypt-volume-with.html">link</a>, I successfully mounted the Truecrypt volume with cryptsetup.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo cryptsetup --type tcrypt open /path/to/truecrypt-volume mapping-name
sudo mount -o uid=1001 /dev/mapper/mapping-name /media/tcv
</code></pre></div></div>

<p>After mouting the trucrypt volume under <strong><em>/media/tsecrets</em></strong> I started to analyze its content.</p>

<p><img src="/assets/truesecrets/truecrypt_content.png" alt="" /></p>

<p><strong><em>AgentServer.cs</em></strong> I was nearly sure that it was the source code of the custom C2 server…and I was right.</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.IO</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Net</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Net.Sockets</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Text</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Security.Cryptography</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">AgentServer</span> <span class="p">{</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">localPort</span> <span class="p">=</span> <span class="m">40001</span><span class="p">;</span>
        <span class="n">IPAddress</span> <span class="n">localAddress</span> <span class="p">=</span> <span class="n">IPAddress</span><span class="p">.</span><span class="n">Any</span><span class="p">;</span>
        <span class="n">TcpListener</span> <span class="n">listener</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">TcpListener</span><span class="p">(</span><span class="n">localAddress</span><span class="p">,</span> <span class="n">localPort</span><span class="p">);</span>
        <span class="n">listener</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Waiting for remote connection from remote agents (infected machines)..."</span><span class="p">);</span>

        <span class="n">TcpClient</span> <span class="n">client</span> <span class="p">=</span> <span class="n">listener</span><span class="p">.</span><span class="nf">AcceptTcpClient</span><span class="p">();</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Received remote connection"</span><span class="p">);</span>
        <span class="n">NetworkStream</span> <span class="n">cStream</span> <span class="p">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">GetStream</span><span class="p">();</span>

        <span class="kt">string</span> <span class="n">sessionID</span> <span class="p">=</span> <span class="n">Guid</span><span class="p">.</span><span class="nf">NewGuid</span><span class="p">().</span><span class="nf">ToString</span><span class="p">();</span>

        <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">string</span> <span class="n">cmd</span> <span class="p">=</span> <span class="n">Console</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">();</span>
            <span class="kt">byte</span><span class="p">[]</span> <span class="n">cmdBytes</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetBytes</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
            <span class="n">cStream</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="n">cmdBytes</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">cmdBytes</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>

            <span class="kt">byte</span><span class="p">[]</span> <span class="n">buffer</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="n">client</span><span class="p">.</span><span class="n">ReceiveBufferSize</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">bytesRead</span> <span class="p">=</span> <span class="n">cStream</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">client</span><span class="p">.</span><span class="n">ReceiveBufferSize</span><span class="p">);</span>
            <span class="kt">string</span> <span class="n">cmdOut</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">ASCII</span><span class="p">.</span><span class="nf">GetString</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">bytesRead</span><span class="p">);</span>

            <span class="kt">string</span> <span class="n">sessionFile</span> <span class="p">=</span> <span class="n">sessionID</span> <span class="p">+</span> <span class="s">".log.enc"</span><span class="p">;</span>
            <span class="n">File</span><span class="p">.</span><span class="nf">AppendAllText</span><span class="p">(</span><span class="s">@"sessions\"</span> <span class="p">+</span> <span class="n">sessionFile</span><span class="p">,</span>
                <span class="nf">Encrypt</span><span class="p">(</span>
                    <span class="s">"Cmd: "</span> <span class="p">+</span> <span class="n">cmd</span> <span class="p">+</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span> <span class="p">+</span> <span class="n">cmdOut</span>
                <span class="p">)</span> <span class="p">+</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span>
            <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">Encrypt</span><span class="p">(</span><span class="kt">string</span> <span class="n">pt</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">string</span> <span class="n">key</span> <span class="p">=</span> <span class="s">"AKaPdSgV"</span><span class="p">;</span>
        <span class="kt">string</span> <span class="n">iv</span> <span class="p">=</span> <span class="s">"QeThWmYq"</span><span class="p">;</span>
        <span class="kt">byte</span><span class="p">[]</span> <span class="n">keyBytes</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetBytes</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
        <span class="kt">byte</span><span class="p">[]</span> <span class="n">ivBytes</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetBytes</span><span class="p">(</span><span class="n">iv</span><span class="p">);</span>
        <span class="kt">byte</span><span class="p">[]</span> <span class="n">inputBytes</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">Text</span><span class="p">.</span><span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetBytes</span><span class="p">(</span><span class="n">pt</span><span class="p">);</span>

        <span class="k">using</span> <span class="p">(</span><span class="n">DESCryptoServiceProvider</span> <span class="n">dsp</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DESCryptoServiceProvider</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">mstr</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MemoryStream</span><span class="p">();</span>
            <span class="kt">var</span> <span class="n">crystr</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CryptoStream</span><span class="p">(</span><span class="n">mstr</span><span class="p">,</span> <span class="n">dsp</span><span class="p">.</span><span class="nf">CreateEncryptor</span><span class="p">(</span><span class="n">keyBytes</span><span class="p">,</span> <span class="n">ivBytes</span><span class="p">),</span> <span class="n">CryptoStreamMode</span><span class="p">.</span><span class="n">Write</span><span class="p">);</span>
            <span class="n">crystr</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="n">inputBytes</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">inputBytes</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
            <span class="n">crystr</span><span class="p">.</span><span class="nf">FlushFinalBlock</span><span class="p">();</span>
            <span class="k">return</span> <span class="n">Convert</span><span class="p">.</span><span class="nf">ToBase64String</span><span class="p">(</span><span class="n">mstr</span><span class="p">.</span><span class="nf">ToArray</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>
<p>So understanding the <strong>AgentServer.cs</strong> file, it encrypts command executions on victims’ computers into session files with DES ciphering and encodes it with Base64.</p>

<p>Under the session <strong><em>malware_agent/sessions/</em></strong> I found  3 encrypted log files generated by the code above:</p>

<ul>
  <li>5818acbe-68f1-4176-a2f2-8c6bcb99f9fa.log.enc</li>
  <li>c65939ad-5d17-43d5-9c3a-29c6a7c31a32.log.enc</li>
  <li>de008160-66e4-4d51-8264-21cbc27661fc.log.enc</li>
</ul>

<p>I wrote the <strong>Decrypt</strong> function to decrypt log files content, but intuitively, I directly chose to decrypt the last line of the last file (i.e <strong><em>de008160-66e4-4d51-8264-21cbc27661fc.log.enc</em></strong>) because I felt that the flag was here (no joke).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+iTzBxkIgVWgWm/oyP/Uf6+qW+A+kMTQkouTEammirkz2efek8yfrP5l+mtFS+bWA7TCjJDK2nLAdTKssL7CrHnVW8fMvc6mJR4Ismbs/d/fMDXQeiGXCA==
</code></pre></div></div>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">Decrypt</span><span class="p">(</span><span class="kt">string</span> <span class="n">ct</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">string</span> <span class="n">key</span> <span class="p">=</span> <span class="s">"AKaPdSgV"</span><span class="p">;</span>
    <span class="kt">string</span> <span class="n">iv</span> <span class="p">=</span> <span class="s">"QeThWmYq"</span><span class="p">;</span>
    <span class="kt">byte</span><span class="p">[]</span> <span class="n">keyBytes</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetBytes</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="kt">byte</span><span class="p">[]</span> <span class="n">ivBytes</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetBytes</span><span class="p">(</span><span class="n">iv</span><span class="p">);</span>
    <span class="kt">byte</span><span class="p">[]</span> <span class="n">inputBytes</span> <span class="p">=</span> <span class="n">Convert</span><span class="p">.</span><span class="nf">FromBase64String</span><span class="p">(</span><span class="n">ct</span><span class="p">);</span>

    <span class="k">using</span> <span class="p">(</span><span class="n">DESCryptoServiceProvider</span> <span class="n">dsp</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DESCryptoServiceProvider</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">mstr</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">MemoryStream</span><span class="p">();</span>
        <span class="kt">var</span> <span class="n">crystr</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CryptoStream</span><span class="p">(</span><span class="n">mstr</span><span class="p">,</span> <span class="n">dsp</span><span class="p">.</span><span class="nf">CreateDecryptor</span><span class="p">(</span><span class="n">keyBytes</span><span class="p">,</span> <span class="n">ivBytes</span><span class="p">),</span> <span class="n">CryptoStreamMode</span><span class="p">.</span><span class="n">Write</span><span class="p">);</span>
        <span class="n">crystr</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="n">inputBytes</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">inputBytes</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
        <span class="n">crystr</span><span class="p">.</span><span class="nf">FlushFinalBlock</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="nf">GetString</span><span class="p">(</span><span class="n">mstr</span><span class="p">.</span><span class="nf">ToArray</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And here is the flag…</p>

<p><img src="/assets/truesecrets/flag.png" alt="" /></p>

<h1 id="conclusion">Conclusion</h1>

<p>This was an easy one. If you have any questions or feedback on this writeup, or if you simply want talk about cybersecurity you can DM me on Twitter <a href="https://twitter.com/o_fenomen0">@o_fenomen0</a> or on Discord <strong>@0xofenomeno</strong>.</p>


</article>
      </section>
    </div>
  </div>

   <footer>
  <a href="https://creativecommons.org/licenses/by-nc/3.0/deed.en_US">
    <span>
        <b>OFenomeno</b>
    </span>
    
    <span>© 2024</span>
  </a>
</footer>

  


  
</body>

</html>